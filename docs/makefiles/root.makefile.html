<p>-e </p>
<h1 id="root-makefile-md">root.makefile.md</h1>
<p><code>root.makefile</code> </p>
<h3 id="local-project-makefile">Local Project Makefile</h3>
<p>Makes source sub-dirs and publishes npm package. </p>
<p><code>common.makefile</code> </p>
<h3 id="common-makefile-library">Common Makefile Library</h3>
<p>Base makefile library<br>This is included from a top level makefile.<br>-e </p>
<h1 id="targets">TARGETS</h1>
<p>.DEFAULT_GOAL = all </p>
<p><code>common.makefile</code> </p>
<p><strong>help</strong>: print this message </p>
<p><strong>printall</strong>: print all public type variables (no underscore; defined in file or command line or environment override) </p>
<p><strong>printall-raw</strong>: print all variables and values known to make </p>
<p><strong>print-%</strong>: print-varname - prints the value of varname </p>
<p><strong>help-use</strong>: print USE_VARNAME type help </p>
<p><strong>help-file</strong>: print help for makefile </p>
<p><strong>help-extra</strong>: print extra help </p>
<p><code>root.makefile</code> </p>
<p><strong>all</strong>: make all sub makes </p>
<p><strong>clean</strong>: clean all sub makes </p>
<p><strong>publish</strong>: publish package to npm registery<br>-e </p>
<h1 id="use-variables">USE VARIABLES</h1>
<p><code>common.makefile</code> </p>
<p><em>Because of technically difficulity in mdless: USE MDLESS should be USE_MDLESS and so on.</em><br><strong>USE MDLESS</strong>: use <a href="https://github.com/ttscoff/mdless">mdless</a> command to form command line markdown output<br><strong>USE COLOR</strong>: colorize output<br>-e </p>
<h1 id="extra-help">EXTRA HELP</h1>
<p><code>common.makefile</code> </p>
<p>run <code>make help</code> see top level non-pattern rules<br>run <code>make help-file</code> help for each included file<br>run <code>make help-use</code> help for USE_\% type variables<br>run <code>make -j 8</code> to run with 8 threads in paralell (set the number to number of cores)!<br>run <code>make -n</code> for a dry run that will print out the actually commands it would have used<br>run <code>make --trace</code> to see all recipe shell commands<br>run <code>make --debug=b</code> basic debug dependency chain </p>
<h4 id="dont-set-bool-type-variables-to-zero-">Dont set bool type variables to zero.</h4>
<p>BAD: <code>USE_THINGY :=0</code><br>GOOD: <code>USE_THINGY :=</code><br>This is because make usually checks for existance of variable being set. </p>
<h4 id="watch-out-with-spaces-when-setting-variables-">Watch out with spaces when setting variables.</h4>
<p>Make is very literal in setting things.<br>BAD: <code>DIR_BASE := .. \\n</code># will evaluate to ..<br>GOOD: <code>DIR_BASE := ..\\n</code># will evaluate to ..<br>So the value starts right after assingment symbol and ends at newline or comment hash. </p>
<h4 id="dont-set-variables-with-the-environment">Dont set variables with the environment</h4>
<p>The -e switch will push the whole environment in and who knows whats in there.<br>Setting variables after the the make command will isolate and document what you are trying to do.<br>BAD: <code>USE_THINGY=1 make -e</code># set through environment<br>GOOD: <code>make USE_THINGY=1</code># set by make<br>Unsetting variables on the command line<br>GOOD: <code>make USE_THINGY=</code></p>
